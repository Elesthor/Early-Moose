channel : boucle d'attente, pb de synchronized, difficile à prouver, cpu => semaphores
description de l'ast : metaproc...

** Arbre de syntaxe abstraite :
Les classes utilisées sont proches de la grammaire, mais notons quelques points :
 - la classe MetaProc représente le Proc de la grammaire
 - la classe Process représente le P
Pour MetaProc et Process, la liste est construite grâce au dernier élément du constructeur qui est respectivement un MetaProc et un Process. La fin est marquée respectivement par un None et par un PTrivial.
Lors du parsing, pour le processus PIf, le processus suivant est toujours initialisé à PTrivial, mais peut être remplacé si le if est parenthése, comme dans le code suivant :
<(if test then 0 else 0).0

Les termes sont représentés par un descendant de la classe Term, et les valeurs par un descendant de la classe Value. Il existe un terme spécial TValue, donc le constructeur prend un objet de type Value, afin de pouvoir voir une valeur comme un terme.

** Le parseur :
Le parsing se fait grâce à la classe Parser, qui prend en argument un objet Input.
La seule méthode abstraite de la classe Input est getChar_. Une fois cette fonction renseignée, via l'une des deux implémentations InputFromFile et InputFromString, la classe Input fournit des fonctions utiles : peek, getWord, getNumber, checkNextWord, et elle gère les commentaires.

Le parsing est scindé en multiples fonctions : parseMetaProc, parseProcess, parseTerm, parseVariable, parseChannel, parseConstant, parseList et parseProcessSeq. Leurs buts découlent des noms, si ce n'est pour parseProcessSeq qui cherche le '.' à la fin d'un process : s'il est présent, elle appelle parseProcess, sinon elle renvoie PTrivial, ce qui fait remonter la pile d'appel jusqu'au parsing d'un MetaProc, ou d'un PIf.

Le fonctionnement de parseProcess et parseTerm est basé sur les délimiteurs : on peut lire un mot jusqu'à un certain délimiteur ((),:>= etc) pour discerner les cas. Dans le cas des process, un pattern matching sur le mot clé lu et le délimiteur permet gérer les cas, et dans le cas des termes, on regarde d'abord s'il s'agit d'un nombre (le premier caractère est - ou un chiffre), puis on effectue de même un pattern matching, et à la fin, on recherche éventuellement un opérateur en notation infixe.

En cas d'erreurs (pas dans la syntaxe, fin du fichier, identifiant illégal) le parseur lève une exception.

À propos des valeurs : les constructeurs qui demandent des valeurs attendent en réalité des termes, qui pourront à l'interprétation être réduit en valeurs. La vérification est donc effectué à l'interprétation.
À propos des constantes : aucune constantes n'est déclaré en dehors du process new. Les déclaration de constantes réduisent les variables portant le même identifiant.
À propos des canaux : lors du parsing, les canaux sont représenté uniquement par leur nom. Ce choix permet de les parser indépendamment de la stratégie d'exécution. Les détails d'implémentation des canaux sont dans la partie suivante (/!\)


